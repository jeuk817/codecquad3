# 컴퓨터의 구성요소
참조 : https://cloudstudying.kr/lectures/183
- 컴퓨터의 구성요소는 3가지로 나누어진다.  
    CPU : 연산을 담당
    Memory : 기억을 담당
    I/O Devices : 다양한 입출력장치

## 컴퓨터의 부팅 과정
컴퓨터가 동작하기 위해 이루어지는 과정을 부팅이라고 한다. 부팅은 초기화 프로그램(initial program)에 의해 수행된다.

1. 컴퓨터에 전원이 들어오면, 초기화 프로그램은 가장 먼저 '펌웨어'를 실행한다.  
    펌웨어란, 모든 컴퓨터의 구성요소를 메모리(Memory)에 저장하여 관리하게 해주는 프로그램이다.
2. 다음으로 초기화 프로그램은 운영체제(OS)의 핵심인 커널(kernel)을 실행한다.  
    커널이란, 컴퓨터 자원을 할당하고, 프로그램을 관리하는 운영체제의 핵심이다.
3. 커널의 수행이 완료되면, 쉘(shell)이 실행되고 부팅과정이 끝난다.  
    쉘이란, 운영체제의 일부로서 커널에게 명령을 해석하여 전달하는 역할을 한다.

## 인터럽트
인터럽트(interrupt)란 컴퓨터에서 발생한 이벤트를 CPU에게 보내는 신호로서, 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다.  
    하드웨어적 인터럽트 : 물리적 신호를 CPU로 직접 전송  
    소프트웨어 인터럽트 : 시스템 콜(system call)이라는 특별한 동작을 통해 수행된다.  

인터럽트가 발생하면 CPU는 하던 작업을 멈추고 즉시 해당 인터럽트를 처리해야 한다. 이러한 처리과정은 해당 인터럽트를 인터럽트 서비스 루틴(interrupt service rutine)에 전달함으로 써 해결한다.


### System Call 이란
참조 : http://blog.naver.com/PostView.nhn?blogId=s2kiess&logNo=30190130352
- 개념 : 응용 프로그램에서 OS에게 "이것 좀 처리해 주세요"하면서 부르는 것.  
즉, 커널에서 사용자에게 제공하는 함수를 호출하게하는 기능.  
(System Call을 활용하면 굳이 Low레벨언어에 대한 이해가 없더라도 손쉽게 프로그래밍을 할 수 있다.)

- 소프트웨어 인터럽트에는 고유한 번호가 존재한다.  
커널에서 System Call의 기능에 따랄 구분짓기 위해 고유하게 붙여놓은 번호인데, 커널은 이 번호를 보고 그에 따른 서비스 루틴을 수행한다.

- System Call은 '소프트웨어 인터럽트'의 한 종류이다.  
위에서 설명한 기능별로 구분지은 고유번호는 IDT(Interrupt Descriptor Table)이라는 곳에 저장된다.  
인터럽트가 일어나면, IDTR이라는 레지스터에 IDT를 가리키는 위치가 명시되어 있다.  
그걸 보고 IDT에서 인터럽트 종류를 확인하고 처리한다.  
(우리가 공부하는 시스템콜은 IDT에서 0x80의 고유번호를 갖는다.)

- System Call이 일어나는 과정
    1. 응용프로그램에서 소프트웨어 인터럽트가 일어난다.
    2. C 라이브러리 (libc.a)에서 기능에 따른 System Call 고유번호가 레지스터에 저장되고 0x80 인터럽트를 건다.
    3. 커널은 IDT 엔트리를 참조하여 알맞은 서비스 루틴을 수행한다.

## 데이터 저장 계층
컴퓨터에는 다양한 데이터 저장장치(storage-device)가 있다. 예를들면 CPU 내부의 레지스터(register)와 캐시(cache), 주 기억장치인 메모리(memory), 그리고 SSD(solid state disk)와 HDD(hard disk drive)등이 있다.



------------------------------------------------

## stack 스택
참조 : https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html
- 개념 : 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료 구조
### stack의 연산 : 가장 최근에 스택에 추가한 항복이 가장 먼저 제거될 항목이다.
- pop(): 스택에서 가장 위에 있는 항목을 제거
- push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.
- peek(): 스택의 가장 위에 있는 항목을 반환한다.
- isEmpty(): 스택이 비어 있을 때에 true를 반환한다.

### stack의 구현  
- 배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다.
- 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.
- 배열처럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.

### Stack의 사용 사례
- 재귀 알고리즘
    * 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
    * 재귀함수를 빠져 나와 퇴각 검색(backtrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼줘야 한다.
    * 스택은 이런 일련의 행위를 직관적으로 가능하게 해 준다.
    * 또한 스택은 재귀 알고리즘을 반복적 형태를 통해서 구현할 수 있게 해준다.
- 웹 브라우저 방문기록(뒤로가기)
- 실행 취소 (undo)
- 역순 문자열 만들기
- 수식의 괄호 검사(연산자 우선순위 표현을 위한 괄호 검사)
- 후위 표기법 계산

### java 라이브러리 Stack 관련 메서드
- push(E item) : 해당 item을 Stack의 top에 삽입
- pop() : Stack의 top에 있는 item을 삭제하고 해당 item을 반환
- peek() : Stack의 top에 있는 item을 삭제하지 않고 해당 item을 반환
- empty() : Stack이 비어있으면 true를 반환 그렇지 않으면 false를 반환
- search(Object o) : 
    * 해당 Object의 위치를 반환
    * Stack의 top 위치는 1, 해당 Object가 없으면 -1을 반환

# Memory 메모리
컴퓨터 내부에 일련의 질서 있는 바이트 저장소가 배치되어 충돌 없이 검색될 수 있도록 마련된 일관되고 연속된 바이트의 배열이다.  

## 메모리 계층구조
메모리 계층 구조란 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다. 이때 필요란 대부분의 경우 CPU가 메모리에 더 빨리 접근하기 위함이다.
- 일반적으로 피라미드형태의 그림으로 나타낸다.(위부터 아래: 레지스터, 캐시, 메모리, 하드디스크)
- 레지스터와 캐시는 CPU 내부에 존재함으로 CPU는 아주 빠르게 접근할 수 있다.
- 메모리는 CPU 외부에 존재한다. 레지스터와 캐시보다 느리게 접근 할 수 밖에 없다.
- 하드디스크는 CPU가 직접 접근할 방법조차 없다. CPU가 하드디스크에 접근하기 위해서는 하드디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다.

# CPU
CPU는 메모리에 있는 프로그램을 정해진 절차대로 실행하는 중앙 처리 장치를 지칭한다.

## CPU의 구조
- CPU는 전체를 제어하는 제어장치, 연산장치, 데이터를 임시 저장하는 레지스터, 메모리 등의 기억장치와의 인터페이스 주변장치와 입출력 장치와의 인터페이스 등으로 구성된다.

## CPU 동작
노이만형 CPU의 기본 동작은 구현에 관계없이 프로그램이라는 명령열을 순차적으로 실행 하는 것이다.  
CPU 중앙처리장치를 다르게 MPU(Micro Process Unit)이라고도 부릅니다.  

### 마이크로 프로세서 4가지 구성요소
![micro process unit 4가지 구성요소](https://t1.daumcdn.net/cfile/tistory/252E554C583B0F5A05)

1. 실행 유닛(EU : Execution Unit) : 마이크로 프로세서의 각 명령어를 수행하는 유닛  
    - 실행 유닛의 구성 : ALU(Arithmetic Logic Unit), 제어 유닛(CU : Control Unit), 레지스터
                        ALU는 덧셈이나 비교연산과 같은 산술연산, 논리연산을 수행한 후 중간 결과를 레지스터에 보관한다.

2. 명령어 유닛(Instruction Unit) : 명령어유닛(Instruction Unit)은 메모리에서 가져온 명령어를 실행유닛에서 수행하도록 제어하는 유닛

3. 어드레싱 유닛(AU : Addressing Unit) : 어디레싱 유닛은 CPU가 메모리 혹은 데이터를 읽거나 쓸 때, 메모리 입출력 어드레스를 만들어주는 유닛

4. 버스 잍너페이스 유닛(BIU : Bus Interface Unit) : 마이크로프로세서는 데이터 버스를 통해 데이터를 메모리에 읽거나 쓸 수 있으며, 데이터를 쓰는데 활용할 메모리 위치는 어드레스에 의해 정해진다. 마이크로 프로세서는 어드레싱 유닛에서 어드레스를 계산한 후 버스로 보내게 되며, 데이터를 읽거나 쓰는 일은 버스유닛에서 수행한다. 버스 유닛에서 데이터를 읽어 들였을 경우 그 데이터가 레지스터에 저장되나 버스 유닛이 명령어를 읽어들였을 경우 명령어가 프리패치큐에 저장된다.

* 레지스터
마이크로 프로세서가 동작하는데 필요한 입.출력 데이터나 어드레스(주소), 연산결과 등을 기억하는 용도로 CPU내부의 임시저장장소를 레지스터라한다.  

* 클럭(Clock)
- 컴퓨터 내부에 CPU와 디지털 회로장치들이 일정한 속도로 동기화하여 작동하도록 펄스인 클럭을 발생시키는 일종의 시계가 있다.
- 메인보드에 있는 이것을 클럭발생기라고 하는데 주로 CPU소켓 주위나 전원부 근처에서 볼 수 있다.

* 캐쉬 메모리(Cache Memory)
- CPU의 동작속도가 급격하게 빨라지면서 CPU는 엄청나게 빠른속도로 동작하게 되었다. 그러면서 주기억장치(RAM)과 주변에 장치들의 데이터전송에서 높낮음이 발생하였고, 이에 따라 병목현상이 발생했다.
- CPU와 RAM의 속도에 많은 차이가 나다보니 CPU와 RAM사이에 고속의 메모리(SRAM)을 두어, 데이터를 자주 읽는 것은 임시로 데이터를 저장함으로서 작업의 속도를 높일 수 있다. 이러한 고속 메모리를 캐쉬(Cache)라고 한다.


- 프로그램은 숫자열로 어떤 메모리에 저장 되어 있다. CPU에서 패치, 디코드, 실행의 세 단계가 존재한다.

1. 패치는 수행할 명령(숫자의 정렬)을 프로그램 메모리에서 꺼낸 것이다. 메모리상의 실행해야할 명령어의 위치는 프로그램 카운터로 지정된다. 프로그램 카운턴는 CPU가 현재 보고있는 프로그램의 위치를 나타내고 있다고 할 수 있다. 명령어 인출에 사용되면 프로그램 카운터는 인출한만큼 증가하게 된다.

2. 


===========================================================
======================Memory 만들기=========================

# 폰노이만구조와 하버드구조
참조 : https://jsy6036.tistory.com/entry/%ED%8F%B0-%EB%85%B8%EC%9D%B4%EB%A7%8C-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%95%98%EB%B2%84%EB%93%9C-%EA%B5%AC%EC%A1%B0  

## 폰노이만(Von Neumann) 구조
프로그램과 데이터를 하나의 메모리에 저장하여 데이터는 메모리에서 읽거나 메모리에 쓰기도 하는 반면, 명령어는 메모리에서 일기만 하는 구조.  

- 특징
    * 명령어와 데이터를 위한 메모리 인터페이스가 하나이다.
    * 명령어를 읽을 때 데이터를 읽거나 쓸 수 없다.
    * 데이터와 명령어 사이에 뚜렷한 구분이 없다.
    * 일반적으로 100에서 250개의 많은 수의 명령어가 있다.
    * 몇몇 명령어는 특별한 동작을 수행하며 자주 사용되지 않는다.
    * 가변 길이 명령어 형식이며 메모리의 피연산자를 처리하는 명령어
    - 데이터에는 고유 의미가 없다.
    - 메모리는 저장공간의 선형(일차원)배열이다.

![폰노이만 구조 모형](https://upload.wikimedia.org/wikipedia/ko/thumb/a/a1/Von_Neumann_architecture_kor.png/375px-Von_Neumann_architecture_kor.png)

## 하버드(Harvard) 구조
폰 노이만 아키텍처의 변형으로써 명령어와 데이터가 서로 다른 메모리영역을 차지하며 메모리 명영마다 주소버스, 데이터버스, 제어버스가 따로 존재한다.  
또한 명령어와 데이터를 동시에 읽어 들일 수 있으며 명령어길이가 표준 데이터크기(워드)로 제한받지 않는다. 명령 구조상으로 RISC구조이다.  

- 특징
    * 프로그램과 데이터를 물리적으로 구분하여 각각 다른 메모리에 저장하는 구조
    * 명령어를 읽을 때 데이터를 읽거나 쓸 수 있어 성능이 우수하다.
    * 버스 시스템이 복잡하여 설계가 복잡하다.
    * 상대적으로 적은 수의 명령어
    * 상대적으로 적은 수의 어드레싱 모드
    * 메모리참조는 load와 store 명령어로만 제한된다.
    * 모든 동작은 CPU의 레지스터 안에서 수행된다.
    * 고정된 길이의 명령어 형식으로 디코딩이 간단하다.
    * 단일 사이클의 명령어 실행
    * 마이크로 프로그램된 제이보다는 하드와이어된 제어를 선택한다.

![하버드구조 모형](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Harvard_architecture.svg/330px-Harvard_architecture.svg.png)  

# 프로세스 메모리 구조
참조 : https://recorda.tistory.com/entry/20160503%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0  

## 메모리구조
- 데이터나 프로그램을 저장하는 저장공간은 계층 구조를 갖는다.
- CPU와 가장 가까운 공간부터 레지스터>CPU캐시>메인메모리>보조기억장치>외부기억장치 순이며, 이 저장공간들은 CPU로부터 멀어질수록 데이터를 저장하는 용량이 커지고 접근하는 속도가 느려진다.

## 가상 메모리
- 실제 시스템에 있는 물리적인 메모리의 크기에 상관 없이 가상공간을 프로세스에게 제공한다.
- 이런 가상메모리는 프로세스 전체가 메모리에 적재되지 않아도 프로세스의 실행이 가능하도록 한다.

## 메모리 구조
: UNIX 시스템은 실행 중인 프로세스에게 4GB의 가상 메모리공간을 할당한다.  
: 상위 1GB는 커널이, 하위#GB는 사용자 프로그램이 차지한다.

![메모리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F245DAB3F572836C11F)  

1. Stack 영역
- 프로그램이 자동으로 사용하는 임시 메모리영역으로 지역변수, 매개변수, 리턴 값 등이 잠시 사용되었다가 사라지는 데이터를 저장하는 영역이다.
- 함수 호출 시 생성되고 함수가 끝나면 반환된다.
- Stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어있어 런타임시 Stack 사이즈를 바꿀 수 없다.
- 명령실행시 자동으로 증가/감소하기 때문에 보통 메모리의 마지막 번지를 지정한다.

2. Heap 영역
- 필요에 의해 메모리를 동적 할당하고자 할 때 사용하는 메모리영역으로 동적 데이터영역이라고 부른다.
- 메모리 주소 값에 의해서만 참조되고 사용하는 영역이다.
- 이 영역에 데이터를 저장하기 위해 C에서 malloc() 함수를 사용한다.

3. Data 영역
- 프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며 전역변수, 정적변수, 배열, 구조체 등이 저장된다.
- 이 때 초기화된 데이터는 Data영역에 저장되고 초기화되지 않은 데이터는 BSS(Block Stated Symbol)영역에 저장된다.
- 함수내부에 선언된 Static변수는 프로그램이 실행될 때 공간만 할당되고 그 함수가 실행될 때 초기화된다.
* Data 영역과 BSS영역을 구분하는 이유는 다음과 같다.
    - 프로그램을 짠 뒤 컴파일하고 링크하고 이미지로 만들어 시스템의 ROM에 저장했다고 가정했을때, 초기화된 데이터는 초기값을 저장해야하니 Data 영역에 저장되어 ROM에 저장된다. 하지만 초기화하지 않은 데이터까지 ROM에 저장한다면 큰 사이즈의 ROM이 필요한데 비용이 많이 들어 RAM에 저장하기 위해 Data영역과 BSS영역으로 나눈 것이다.  

4. Code 영역
- 코드 자체를 구성하는 메모리영역으로 Hex파일이나 Bin파일 메모리다.
- 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 메모리 영역이다.

* Code, Data, BSS 영역은 컴파일 시 크기가 결정되고 Heap, Stack 영역은 런타임 시 크기가 결정된다.

* Stack의 지역변수는 사용하고 소멸하므로 데이터 용량이 불확실하다.
* 그렇기 때문에 밑에서부터 채워 올리고 Heap은 위에서부터 채워나간다.
* 이렇게 서루 주소값을 채워나가다가 Heap에서 Stack방향으로 영역을 침범하는 경우 HEAP overflow라고하며 반대로 Stack에서 Heap방향으로 영역을 침범하면 STACK overflow라고 한다.

