<!-- - 클로저에 대해서 설명해보세요.
- let과 const의 차이에 대해서 설명해보세요.
- 비동기 코드에서 콜백큐와 콜스택에 관계에 대해서 설명해보세요.
- prototype chain은 무엇인가요? 
- constructor 는 무엇인가요?  -->
- this키워드의 상황별 동작에 대해서 설명해보세요.
- Node.js에서 require 를 통한 모듈관리 방법의 원리는 무엇인가요? 
- bind는 무엇을 할때 쓰는 것인가요? 동작방식에 대해서 설명해보세요.
- destructuring 예시코드를 작성해보세요.
<!-- - arrow function과 일반 function의 차이에 대해서 설명하세요. -->

<!-- ```javascript
const animals = {
 run() {
     console.log('열심히 달린다');
 },

 jump() {
     console.log('팔짝팔짝 뛴다');
 },

 bike() {
     console.log('')
 },

 info() {
     console.log(`name is ${this.name}, age is ${this.age}`);
 }
}


const animalFactory = (name, age) => {
 return Object.assign(Object.create(animals), {name:name, age:age});
 //Object.create, Obect.assign
}

const man = animalFactory('crong', 13);
console.log(man);
``` -->

```javascript
// 즉시실행 함수 표현: 정의되자마자 즉시실행되는 자바스크립트 함수
// 1. 괄호로 둘러싸인 익명함수다. 이는 전역 스코프에 불필요한 변수를 추가해서 오염시키는 것을 방지할 수있으머, IIFE내부의 변수에 접근하지 못하도록 막을 수 있다.
// 2. 즉시 실행함수를 생성하는 괄호. 이를 통해 자바스크립트 엔진은 함수를 즉시 해석해서 실행한다.

(function () {
    statements
})();

//아래처럼 인자를 대입할 수 도 있다.
var greet = function(name){
    return 'Hello ' + name;
}('Jason'); // 바로 Hello Jason 출력

// 이제 greet는 더 이상 function이 아니라 string이 됨
greet(); //에러
```

## 클로저에 대해서 설명해보세요.
- 클로저는 함수와 그 함수가 선언된 어휘적 환경의 조합입니다..
- 다시말해 외부함수와 내부함수가 있을 때, 외부함수가 실행되고 소멸되더라도 내부함수가 자신이 선언된 외부함수의 어휘적 환경에 접근 할 수 있습니다.
- 예를들어 외부함수 A가 변수 B와 B를 반환하는 내부함수 C를가지고 있다고 가정하고, 변수 D에 A함수를 할당하고 D를 실행시키면 내부함수C가 실행되면서 B가 반환됩니다.
- 이러한 특성때문에 클로저는 일반적으로 사이드이팩트 제어와 private 변수를 생성하기 위한 목적으로 사용됩니다.

## let과 const의 차이에 대해서 설명해보세요.
- let은 변수선언 키워드로 값 재할당이 가능하다. 하지만 const는 상수선은 키워드로 값 재할당이 불가능 하다.
- 그리고 let은 변수를 선언한 후에 할당을 할 수 있지만, const는 선언과 동시에 값을 할당해야만 한다.

## 비동기 코드에서 콜백큐와 콜스택에 관계에 대해서 설명해보세요.
- 콜스택에 호출된 비동기 코드들는 Web APIs를 거쳐 콜백큐에 쌓이게 된다.
- 콜백큐에 쌓인 코드들은 콜스택이 비게되면 이벤트루프에 의해서 콜스텍에 다시 호출된다.
- 이러한 과정을 거치는 이유는 자바스크립트가 싱글 스레드 언어이기 때문에 많은 처리시간이 걸리는 함수를 비동기 처리하기 위해서 입니다.

## prototype chain은 무엇인가요? 
- 프로토타입 체인이란 프로토타입 객체를 이용하여 객체와 객체를 연결하고 한쪽 방향으로 상속받는 형태를 만드는 것입니다. 
- 이렇게 상속이 이루어지면 객체의 속성이나 매소드를 참조할 때, 먼저 자신 안에서 속성이나 매소드가 정의되어 있는지 찾아본 다음, 발견하지 못하면 프로토타입 링크를 타고 부모객체로 올라가 찾습니다.

## constructor 는 무엇인가요? 
- constructor(생성자)는 객체를 만드는 역할을 하는 함수다. 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작 합니다. 생성자 함수를 구분하기 위해 생성자 함수의 첫 문자는 대문자로 표기하는 것이 관례입니다.
- 생성자 메소드는 클래스가 객체로 생성되고 초기값을 설정하기 위한 특별한 메소드 입니다. 그리고 생성자함수와는 달리 일반 함수의 기능이 없습니다. new 연산자 없이는 호출 할 수 가 없습니다.

## this키워드의 상황별 동작에 대해서 설명해보세요.
- 대부분의 경우 this의 값은 함수를 호출한 방법이 결정합니다.
- 전역 실행문맥에서는 this는 엄격모드 여부에 관계없이 전역 객체를 참조합니다.
- 함수 문맥에서는 

## arrow function과 일반 function의 차이에 대해서 설명하세요.
- 일반 함수의 this는 바인딩할 객체가 동적으로 결정되고, 화살표함수의 this는 정적으로 결정된다.
- 일반함수를 선언할 때 this에 바인딩할 객체의 결정은 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 콜백 함수 내부의 this는 전역 객체 window를 가리킨다.
- 반면 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. 화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.
- 화살표 함수는 익명함수로만 사용할 수 있다. 따라서 화살표 함수를 호출하기 위해서는 함수 표현식을 사용해야 한다. 또는 콜백함수로 사용할 수 있다.